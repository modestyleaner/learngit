head first  设计模式 

  学习技巧：
  
  1 慢一点，你理解的越多，你需要记住的就越少：不止是看，要多思考，遇到问题，不要直接看答案，而是去思考，收获会更多
	  
  2 多动手，勤练习，自己记笔记
  
  3 多喝水
  
  4 上床之前，不要再看其他有难度的东西了，把刚才学习的东西多理解理解
  
  5 大声说出来，将自己的理解有语言进行组织，可以起到不同凡响的效果
  
  6 听听你的大脑怎么说：如果大脑负荷过重，则可以适当休息一会
  
  7 要有点感觉： 大脑知道这是很重要的知识，需要记住！
  
  8 设计一些东西，可以是重构一些项目代码，或者解决一个难题
  
  
  
  /****************第一章   策略模式  strategy pattern ****************************************/
  
  心得一： 当涉及到维护时，为了"复用 reuse"目的而是用继承，结局并不完美
  真理：  软件开发中一个永远不变的真理就是： change ！！！！
  
  设计原则： 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起！
  
  设计原则： 针对接口编程，而不是针对实现编程！
  
  设计原则： “有一个 即  has  a ”的思想比 “是一个 is a ”的思想好. 即 多用 “组合" 少用  ”继承"
  
  模式： 策略 模式： 定义了算法族，分别封装起来，让他们之间可以相互替换。此模式让算法的变化独立于使用算法的客户
  
  共享模式词汇的威力：
   1 使用模式名称和其他队友沟通时，交流的不止是名称，还有一整套模式背后的所象征的质量，约束和特性。
   2 模式可以让你用更少的词汇做更充分地沟通
   3 将说话的方式保持在模式层次，可以让你在“设计圈” 呆久一点
   4 共享词汇可以帮助你的开发团队快速充电
   5 共享词汇可以帮助初级开发人员快速成长
   
/****************第二章  观察者模式 Observer pattern *************************************/

  出版者+订阅者 == 观察者模式
  
  在观察者模式中： 出版者即 “主题” Subject 
				   订阅者即 “观察者” Observer
				   
  观察者模式： 定义了对象之间的一对多关系，这样，当一个对象发生变化时，它的所有依赖者都会得到通知，并且更新。
  
  
/************* 第三章 装饰模式 ***********************************/
   
   设计原则：类应该对扩展开放，对修改关闭.
   
   注意： 在选择要扩展的代码时，一定要小心，每个地方采用开放-关闭原则，是一种浪费，也没有必要，导致代码复杂而且难于理解。
   
   
   装饰者模式： 动态的将责任添加到对象上。若要拓展功能，装饰者提供了比继承共有弹性的替代方案。
   
   java.io 的相关类使用的就是  装饰者模式
   

/**************第4章 工厂模式 ****************************************/

	使用new 关键字进行对象的创建，实例化一个具体的类。所用为 实现而不是 接口
	
	Duck duck = new MallardDuck();
	
	Duck duck ;
	if(pink){
		duck = new MallardDuck();
	}else if(hunting){
		duck = new DecoyDuck();
	}else{
		duck = new RubberDuck();
	}
	
	正如上面的所示，虽然Duck是接口，但是当需要创建具体对象时，还是需要根据条件来进行判断
	这样当 条件发生改变时，就必须重新打开这段代码进行修改，使得部分系统更难维护和更新。
	
	因此如何将 实例化具体类的代码从代码中抽取出来，封装起来，使其不干扰应用的其他部分。
	
	工厂 负责处理创建对象的细节，
	
	工厂方法模式： 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法
	让类把实例化推迟到子类。
	
	依赖导致原则： 要依赖抽象，不要依赖具体类
	
	
	
	

   
  
  




































   